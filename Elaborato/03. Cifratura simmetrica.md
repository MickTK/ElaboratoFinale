\nuovocapitolo{3. Cifratura simmetrica}

# 3. Cifratura simmetrica
Dopo aver visto come effettuare la digestione di un dato tramite gli algoritmi di hashing, andremo a vedere come implementare degli algoritmi di cifratura simmetrica. Vedremo i più utilizzati passando dalla cifratura a flusso alla cifratura a blocco.

La libreria *PyCryptoDome* ci offre diversi algoritmi, quali: ChaCha20,XChaCha20, Salsa20 e AES. Per l'algoritmo AES ci offre una serie di modalità di cifratura a blocco che è possibile utilizzare, tra cui: ECB, CBC, CFB, OFB, CTR, OPENPGP, CCM, EAX, SIV, GCM, OCB.

Vedremo ora come implementare ed utilizzare alcuni di questi per delle semplici applicazioni.

## 3.1. One-Time Pad
Una funzione *One-Time Pad* consiste nel cifrare un messaggio, bit per bit, utilizzando una chiave generata casualmente che, successivamente all'utilizzo, verrà deprecata.

Per prima cosa andiamo ad importare i moduli che ci servono:

```python
import binascii
import secrets
import string
```

Andiamo poi a definire le funzioni che andremo ad utilizzare.

La cifratura avverrà bit per bit tramite uno XOR quindi abbiamo bisogno di convertire il messaggio dichiarato come stringa in un tipo sul quale è permessa l'operazione logica. In Python è possibile effettuare lo XOR sia su valori binari che su valori interi.

```python
# Conversione di un messaggio da stringa a intero
def toInt(message):
  msg = message.encode()      # Conversione in binario
  msg = binascii.hexlify(msg) # Conversione in esadecimale
  msg = int(msg, 16)          # Conversione in intero
  return msg
```

```python
# Conversione di un messaggio da intero a stringa
def toStr(message):
  msg = format(message, 'x')         # Conversione in esadecimale
  msg = ('0' * (len(msg) % 2)) + msg # Padding del messaggio
  msg = binascii.unhexlify(msg)      # Conversione in binario
  msg = msg.decode()                 # Conversione in stringa
  return msg
```

Per l'ottenimento di una chiave, andiamo a definire una funzione che restituisce un token casuale ad ogni chiamata. La chiave sarà di tipo stringa e avrà come lunghezza il valore numerico passato come parametro (uguale alla lunghezza del messaggio da cifrare).

```python
# Generazione chiave casuale
def genKey(length):
  key = ''
  for i in range(length):
    key += secrets.choice(string.ascii_letters)
  return key
```

A questo punto possiamo andare a cifrare e/o decifrare un dato messaggio nel seguente modo:

```python
message = 'Ciao mondo!'
key = genKey(len(message))
encrypted_message = toInt(message) ^ toInt(key)
decrypted_message = toStr(encrypted_message ^ toInt(key))
```

Il carattere *^* permette di eseguire lo XOR logico tra i due valori dati.

\nuovapaginasinistra

## 3.2. Cifratura e decifratura messaggio testuale con cifrario a flusso
Abbiamo un messaggio che vogliamo mandare a qualcuno senza che terzi possano avere accesso al suo contenuto. Per farlo abbiamo bisogno di un metodo sicuro ed efficiente da utilizzare. La libreria *PyCryptoDome* ci offre tre algoritmi di cifratura a flusso: *Salsa20*, *ChaCha20* e *XChaCha29*.

Per il nostro esempio andremo ad utilizzare l'algoritmo *Salsa20* in quanto algoritmo maggiormente conosciuto ed utilizzato.

```python
from Crypto.Cipher import Salsa20
```

Andiamo a costruire un sistema di cifratura e decifratura di un messaggio tramite chiave privata.

Per prima cosa definiamo il messaggio da cifrare e generiamo una chiave casuale:

```python
plaintext = input("Inserire un messaggio da cifrare: ").encode()
key = secrets.token_bytes(32)
```

Inizializziamo l'oggetto utilizzato per la cifratura e con esso cifriamo il messaggio, andando a porre in testa il vettore iniziale generato dallo stesso oggetto:

```python
cipher = Salsa20.new(key)
message = cipher.nonce + cipher.encrypt(plaintext)
```

Nello script d'esempio vengono salvati sia il messaggio cifrato che la chiave nei rispettivi file: *key.pem* e *message.txt*.

A questo punto il messaggio può essere trasmesso al destinatario utilizzando un mezzo non sicuro, mentre la chiave tramite un mezzo sicuro. Vedremo nello specifico come fare in un capitolo successivo. Per ora facciamo finta di avere già un canale sicuro di trasmissione della password.

Quindi, una volta ricevuto sia il messaggio che la chiave da parte del mittente, andiamo a decifrare il messaggio.

Viene prelevato e rimosso il vettore iniziale dal messaggio:

```python
nonce = message[:8]
ciphertext = message[8:]
```

Viene inizializzato l'oggetto passando al costruttore la chiave ed il vettore iniziale come parametri:

```python
cipher = Salsa20.new(key, nonce)
```

Viene infine decifrato il messaggio:

```python
plaintext = cipher.decrypt(ciphertext)
```

## 3.3. Cifratura e decifratura file con cifrario a blocco
Abbiamo visto nel paragrafo precedente come viene cifrato e decifrato un messaggio testuale. Andremo ora a vedere come cifrare e decifrare un file utilizzando l'algoritmo AES in modalità CBC.

Vengono per prima cosa importati i moduli, le classi e le funzioni che verranno utilizzate:

```python
import os
import secrets
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad
```

Vengono dichiarate le dimensioni dei blocchi e la lunghezza della chiave privata.

```python
IV_LENGTH = AES.block_size
KEY_LENGTH = 16
RESERVED_BYTES = 64
```

\nuovapaginadestra

- IV_LENGTH rappresenta la lunghezza del vettore iniziale che in AES è lungo esattamente quanto un blocco;
- KEY_LENGTH rappresenta la lunghezza della chiave privata utilizzata. Nell'esempio viene usato lo standard AES-128 che utilizza chiavi di 16B (128b);
- RESERVED_BYTES rappresenta la lunghezza dei metadati presenti su file. In genere i file system mantengono le informazioni sui file (dimensione, tipo di compressione, data e ora, diritti d'autore ecc.) nei primi byte del file stesso. I byte utilizzati possono cambiare da un tipo di file ad un altro. Per il nostro esempio 64B sono più che sufficienti.

Vengono generati il vettore iniziale e la chiave.

```python
iv = secrets.token_bytes(IV_LENGTH)
key = secrets.token_bytes(KEY_LENGTH)
```

A questo punto è possibile scindere il funzionamento del sistema in due parti: una parte per la cifratura del file e una parte per la decifratura del file.

La funzione di cifratura eseguirà i seguenti compiti:

```python
def encrypt(file_in, file_out):
  # Inizializzazione classe crittografica
  cipher = AES.new(key, AES.MODE_CBC, iv)
  # Lettura file da cifrare
  with open(file_in, "rb") as file:
    byteblock = file.read()
  # Padding dei dati da cifrare
  ciphertext = pad(byteblock[RESERVED_BYTES:], AES.block_size)
  # Cifratura dati
  ciphertext = byteblock[:RESERVED_BYTES] + cipher.encrypt(ciphertext)
  # Scrittura file con dati cifrati
  with open(file_out, "wb") as file:
    file.write(ciphertext)
```

Nella funzione di cifratura è stato eseguito il padding sui dati da cifrare per far combaciare la dimensione del blocco con la dimensione del blocco richiesta dalla modalità CBC ossia un multiplo di 16B. I metadati vengono posti in chiaro in testa ai dati cifrati.

La funzione di decifratura eseguirà invece questi compiti:

```python
def decrypt(file_in, file_out):
  # Inizializzazione classe crittografica
  cipher = AES.new(key, AES.MODE_CBC)
  # Lettura file da decifrare
  with open(file_in, "rb") as file:
    byteblock = file.read()
  # Decifratura dati
  plaintext = cipher.decrypt(byteblock[RESERVED_BYTES:])
  # Unpadding dei dati da decifrare
  plaintext = unpad(plaintext, AES.block_size)
  # Concatenazione byte riservati con dati decifrati
  plaintext = byteblock[:RESERVED_BYTES] + plaintext
  # Scrittura dati decifrati
  with open(file_out, "wb") as file:
    byteblock = file.write(plaintext)
```

Nell'esempio viene utilizzata un'immagine, già presente nella cartella, della quale vengono generati due file: *encripted_image.jpg* e *decripted_image.jpg*.
